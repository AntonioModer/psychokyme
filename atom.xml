<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[My Little Peaceful Grove of Regret and Shame]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://psychoky.me/"/>
  <updated>2015-01-09T08:12:35.987Z</updated>
  <id>http://psychoky.me/</id>
  
  <author>
    <name><![CDATA[adnzzzzZ]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Tilemap to Collision Geometry]]></title>
    <link href="http://psychoky.me/2015/01/09/tilemap-to-collision-geometry/"/>
    <id>http://psychoky.me/2015/01/09/tilemap-to-collision-geometry/</id>
    <published>2015-01-09T07:55:15.000Z</published>
    <updated>2015-01-09T07:56:52.000Z</updated>
    <content type="html"><![CDATA[<p>This post explains an algorithm for turning a tilemap into level geometry<a id="more"></a>.</p>
<h2 id="_"> </h2>
]]></content>
    <summary type="html">
    <![CDATA[<p>This post explains an algorithm for turning a tilemap into level geometry]]>
    
    </summary>
    
      <category term="geometry" scheme="http://psychoky.me/tags/geometry/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Behavior Trees #2]]></title>
    <link href="http://psychoky.me/2014/08/17/behavior-trees-number-2/"/>
    <id>http://psychoky.me/2014/08/17/behavior-trees-number-2/</id>
    <published>2014-08-17T06:46:00.000Z</published>
    <updated>2015-01-09T08:12:08.000Z</updated>
    <content type="html"><![CDATA[<p>This tutorial features a full implementation of behavior for an enemy using behavior trees<a id="more"></a>. The previous part of went over the basics of behavior trees as well as their implementation. So look there first if you somehow got here randomly. The enemy behavior we’re going to implement is actually quite simple from a player/viewer standpoint, but it’s a nice way to introduce most concepts behind behavior trees.</p>
<p>The enemy is going to have three (3) main modes of behaving:</p>
<ul>
<li>Idle</li>
<li>Suspicious</li>
<li>Threatened</li>
</ul>
<p>In the idle mode the enemy will be able to either: wander around its spawn point, talk to another enemy or practice his TK (telekinesis) on a nearby object.  The suspicious mode is triggered whenever the player gets close enough to an enemy. When it is triggered the enemy spawns a question mark above his head and turns towards the player while doing nothing. If the player leaves this trigger area then the enemy goes back to the idle mode, otherwise he stays here.  The threatened mode happens when the player gets really really close to the enemy, in which case the enemy will spawn an angry face above his head, chase the player around and attempt to hit him.</p>
<h2 id="Wander">Wander</h2>
<p>Using the <em>findWanderPoint</em> and <em>moveToPoint</em> actions from the last article, we can start building the idle <em>wander</em> behavior. A small addition to that particular sequence is adding an action that makes the entity wait around for a few seconds before choosing the next point, otherwise he moves around too much.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">wait = Action:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait:new</span><span class="params">(duration)</span></span></div><div class="line">    wait.super.new(self, <span class="string">'wait'</span>)</div><div class="line">  </div><div class="line">    self.wait_duration = duration</div><div class="line">    self.done = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> wait.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">if</span> self.done <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'success'</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'running'</span> <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait:start</span><span class="params">(context)</span></span></div><div class="line">    context.object.timer:after(self.wait_duration, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> self.done = <span class="keyword">true</span> <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait:finish</span><span class="params">(status, context)</span></span></div><div class="line">    self.done = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>Here, like with the Timer decorator, we just set a timer so that after <em>wait_duration</em> seconds this action returns success. Before that happens it will just return running and the sequence won’t be able to move on, which will make the entity do nothing. The tree for the behavior looks like this:</p>
<img src="/images/idle-wander.png" class="center">

<p>We use a sequence to bind everything together. If at any point <em>moveToPoint</em> fails, then <em>wait</em> will not run and the tree will just start over by finding a new point. If the tree succeeds then the entity will have done what we wanted it to do: move to a point and then wait around a bit. After that the tree will just restart and so on…</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">self.behavior_tree = Root(self,</div><div class="line">    Sequence(<span class="string">'wander'</span>, {</div><div class="line">        findWanderPoint(self.x, self.y, <span class="number">100</span>),</div><div class="line">        moveToPoint(),</div><div class="line">        wait(<span class="number">5</span>),</div><div class="line">    })</div><div class="line">)</div><div class="line">...</div></pre></td></tr></table></figure>

<img src="/images/idle-wander.gif" class="center">

<h2 id="TK_Practice">TK Practice</h2>
<p>As you can see in that gif there’s a box lying around. To add some more personality to each enemy we’re going to make it so that sometimes they practice their TK on objects around the map. The idea of this game I’m working on is that it’s a school full of people with TK, so it makes sense that sometimes they’d practice it!</p>
<p>To do this we’re going to need two actions: one to check if there’s any object that can be TKed around, and another to do the actual lifting. First, let’s do the one that finds an object:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">anyAround = Action:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anyAround:new</span><span class="params">(object_types, radius)</span></span></div><div class="line">    anyAround.super.new(self, <span class="string">'anyAround'</span>)</div><div class="line">  </div><div class="line">    self.object_types = object_types</div><div class="line">    self.radius = radius</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anyAround:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> anyAround.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anyAround:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="comment">-- Query for entities of object_types around a circle of </span></div><div class="line">    <span class="comment">-- radius radius centered in x, y</span></div><div class="line">    <span class="keyword">local</span> x, y = context.object.body:getPosition()</div><div class="line">    <span class="keyword">local</span> entities = context.object.world:queryAreaCircle(x, y, </div><div class="line">                     self.radius, self.object_types)</div><div class="line">    <span class="comment">-- If no entities then fail</span></div><div class="line">    <span class="keyword">if</span> #entities == <span class="number">0</span> <span class="keyword">then</span> </div><div class="line">        <span class="keyword">return</span> <span class="string">'failure'</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="comment">-- Pick a random entity that isn't the entity this tree is attached to,</span></div><div class="line">        <span class="comment">-- set context.any_around_entity to point it and then succeed</span></div><div class="line">        <span class="keyword">local</span> entity = entities[<span class="built_in">math</span>.random(<span class="number">1</span>, #entities)]</div><div class="line">        <span class="keyword">while</span> entity.id == context.object.id <span class="keyword">do</span> </div><div class="line">            entity = entities[<span class="built_in">math</span>.random(<span class="number">1</span>, #entities)] </div><div class="line">        <span class="keyword">end</span></div><div class="line">        context.any_around_entity = entity </div><div class="line">        <span class="keyword">return</span> <span class="string">'success'</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anyAround:start</span><span class="params">(context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anyAround:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p><em>anyAround</em> is a conditional type of action that will ask a question to the game’s world and return the answer. In this case, the side effect is changing <em>context.any_around_entity</em> to point to some entity of some type around a certain point with some radius. The idea is that before the NPC can move to the object he wants to lift he needs to first find it. Separating finding and moving makes it so that both can be reused later and, as we’ll see, <em>anyAround</em> will be reused a lot.</p>
<p>There’s one problem so far, though. Ideally we want this subtree to look like this:</p>
<img src="/images/tk-practice-ideal.png" class="center">

<p>But <em>anyAround</em> sets <em>context.any_around_entity</em> to point to the entity, while <em>moveToPoint</em> looks for <em>context.move_to_point_target</em> to move to the target. There are two solutions to this: either add an additional node that always succeeds and translates <em>any_around_entity</em> to <em>move_to_point_target</em>, or change <em>moveToPoint</em> so that it also looks <em>any_around_entity</em> and then translates that into a point it can use. I’ll use the second and this small refactor will be omitted.</p>
<p>Finally, the <em>TKLift</em> action, which does all the lifting work, uses <em>any_around_entity</em> and changes its z velocity:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">tkLift = Action:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tkLift:new</span><span class="params">()</span></span></div><div class="line">    tkLift.super.new(self, <span class="string">'tkLift'</span>)</div><div class="line">  </div><div class="line">    self.done = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tkLift:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> tkLift.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tkLift:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">if</span> self.done <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'success'</span> <span class="keyword">end</span></div><div class="line">    <span class="keyword">if</span> context.any_around_entity <span class="keyword">then</span></div><div class="line">        <span class="comment">-- Change z velocity so that the targetted entity goes up a bit</span></div><div class="line">        context.any_around_entity.v_z = -mg.utils.<span class="built_in">math</span>.random(<span class="number">10</span>, <span class="number">30</span>)</div><div class="line">        <span class="keyword">return</span> <span class="string">'running'</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'failure'</span> <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tkLift:start</span><span class="params">(context)</span></span></div><div class="line">    context.object.tk_charging = <span class="keyword">true</span></div><div class="line">    <span class="comment">-- This action lasts between 0.5 and 1.5 seconds</span></div><div class="line">    context.object.timer:after({<span class="number">0.5</span>, <span class="number">1.5</span>}, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> self.done = <span class="keyword">true</span> <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tkLift:finish</span><span class="params">(status, context)</span></span></div><div class="line">    <span class="comment">-- Clean everything up, including removing the reference to the </span></div><div class="line">    <span class="comment">-- targetted entity from the context. Since Lua's GC uses </span></div><div class="line">    <span class="comment">-- reference counting to remove its objects from memory this </span></div><div class="line">    <span class="comment">-- is super important!!!</span></div><div class="line">    context.any_around_entity = <span class="keyword">nil</span></div><div class="line">    context.object.tk_charging = <span class="keyword">false</span></div><div class="line">    self.done = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>And then after that we tie it all to a sequence. And since we want the enemy to do one thing or the other, either try to lift objects or wander around, we use a selector on top of that. The order in which we place each subtree also matters a lot. Suppose we do selector -&gt; wander, lift. The <em>wander</em> sequence rarely fails, which means that the selector would succeed whenever <em>wander</em> succeeded, which means that <em>tkLift</em> would never really be picked. <em>tkLift</em> fails whenever there isn’t a particular object around, which means that placing it before the <em>wander</em> subtree makes more sense.</p>
<img src="/images/tk-practice-wander.png" class="center">

<img src="/images/box-w.gif" class="center">

<p>There’s still a problem, though. As you can see in the gif, whenever the NPC finds a box once he’ll be addicted to lifting it. That’s because there are no checks in place to keep this from happening. The <em>anyAround</em> query will always return success after the first time, because there will be a box around, and so the whole lifting sequence will be performed and it will repeat again forever. To prevent this from happening we can either try creating a decorator or performing an additional check by creating another action. I’ll choose to go with the decorator one:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">DontSucceedInARow = Decorator:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DontSucceedInARow:new</span><span class="params">(behavior)</span></span></div><div class="line">    DontSucceedInARow.super.new(self, <span class="string">'DontSucceedInARow'</span>, behavior)</div><div class="line">  </div><div class="line">    self.past_status = <span class="string">'invalid'</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DontSucceedInARow:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> DontSucceedInARow.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DontSucceedInARow:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">local</span> status = self.behavior:update(dt, context)</div><div class="line">    <span class="comment">-- If success now and the last run was successful as well then fail!</span></div><div class="line">    <span class="keyword">if</span> status == <span class="string">'success'</span> <span class="keyword">and</span> self.past_status == <span class="string">'success'</span> <span class="keyword">then</span></div><div class="line">        <span class="comment">-- Dirty hack: since moveToPoint now also reads in </span></div><div class="line">        <span class="comment">-- context.any_around_entity, we remove the reference here </span></div><div class="line">        <span class="comment">-- to avoid adding a node that does this. If this reference </span></div><div class="line">        <span class="comment">-- isn't removed then the NPC will still be addicted to </span></div><div class="line">        <span class="comment">-- following the same box around, it'll just do never lift </span></div><div class="line">        <span class="comment">-- the box twice in a row. And this can't reference can't </span></div><div class="line">        <span class="comment">-- be removed in anyAround either because there's nowhere </span></div><div class="line">        <span class="comment">-- to do it there where it won't affect behaviors that might </span></div><div class="line">        <span class="comment">-- need to use the reference.</span></div><div class="line">        context.any_around_entity = <span class="keyword">nil</span></div><div class="line">        self.past_status = <span class="string">'failure'</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'failure'</span></div><div class="line">    <span class="keyword">else</span> </div><div class="line">        self.past_status = status</div><div class="line">        <span class="keyword">return</span> status </div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DontSucceedInARow:start</span><span class="params">(context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DontSucceedInARow:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>Now whenever <em>anyAround</em> succeeds twice in a row a failure will be forced. That failure existing, the tree will be able to move on to try out the <em>wander</em> subtree, which means the NPC won’t get stuck in the same box again.</p>
<img src="/images/dont-succeed.png" class="center">

<img src="/images/box-w3.gif" class="center">

<p>And so the whole tree looks like this:</p>
<img src="/images/tk-lift-wander.png" class="center">

<p>And the code to do that like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">self.behavior_tree = Root(self,</div><div class="line">    Selector(<span class="string">'idle'</span>, {</div><div class="line">        Sequence(<span class="string">'TK practice'</span>, {</div><div class="line">            DontSucceedInARow(anyAround({<span class="string">'Box'</span>}, <span class="number">50</span>)),</div><div class="line">            moveToPoint(),</div><div class="line">            tkLift(),</div><div class="line">        }),</div><div class="line">  </div><div class="line">        Sequence(<span class="string">'wander'</span>, {</div><div class="line">            findWanderPoint(self.x, self.y, <span class="number">100</span>),</div><div class="line">            moveToPoint(),</div><div class="line">            wait(<span class="number">5</span>),</div><div class="line">        })</div><div class="line">    })</div><div class="line">)</div><div class="line">...</div></pre></td></tr></table></figure>

<h2 id="Talking_to_Friends_1">Talking to Friends 1</h2>
<p>This is the first kinda complex behavior and there are multiple ways of going about doing it. The goal is to get the NPCs to talk to each other somehow. The way I’ll do it is by creating <em>FriendMeetingPoint</em> objects, to which NPCs will be able to attach themselves to and wait around for other NPCs to attach themselves to those points and then they’ll be able to talk. The first step to doing that is finding and moving to one of those <em>FriendMeetingPoints</em>. Similarly to how we move to a box in the <em>tkLift</em> behavior, we can use <em>anyAround</em> and <em>moveToPoint</em>:</p>
<img src="/images/talk-friend-1.png">

<p>And this works fine. However, there’s some repetition going on there. The DontSucceedInARow, anyAround -&gt; moveToPoint subtree looks exactly the same in <em>TK practice</em> as it does in <em>friend talk</em>. Luckily, there’s a way of removing this repetition by storing subtrees!</p>
<h2 id="Storing_Subtrees">Storing Subtrees</h2>
<p>Storing a subtree simply means that you’ll take the way in which those nodes are arranged and you’ll store it so you don’t have to type it all again whenever you wanna reuse it. Think of it like a function that you call and that builds that whole subtree with the arguments you pass to it. </p>
<img src="/images/find-and-move-to.png">

<p>And the way to achieve that, at least in Lua, is exactly like thinking of it as a function. We simply create a file that returns a function that returns the built subtree:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(object_types, radius)</span></span></div><div class="line">    <span class="keyword">return</span> Sequence(<span class="string">'findAndMoveTo'</span>, {</div><div class="line">        DontSucceedInARow(anyAround(object_types, radius)),</div><div class="line">        moveToPoint(),</div><div class="line">    })</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>And then to call it:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">self.behavior_tree = Root(self,</div><div class="line">    Selector(<span class="string">'idle'</span>, {</div><div class="line">        Sequence(<span class="string">'TK practice'</span>, {</div><div class="line">            findAndMoveTo({<span class="string">'Box'</span>}, <span class="number">50</span>),</div><div class="line">            tkLift(),</div><div class="line">        }),</div><div class="line">  </div><div class="line">        Sequence(<span class="string">'friend talk'</span>, {</div><div class="line">            findAndMoveTo({<span class="string">'FriendMeetingPoint'</span>}, <span class="number">100</span>),</div><div class="line">        }),</div><div class="line">  </div><div class="line">        Sequence(<span class="string">'wander'</span>, {</div><div class="line">            findWanderPoint(self.x, self.y, <span class="number">100</span>),</div><div class="line">            moveToPoint(),</div><div class="line">            wait(<span class="number">5</span>),</div><div class="line">        })</div><div class="line">    })</div><div class="line">)</div><div class="line">...</div></pre></td></tr></table></figure>

<h2 id="Talking_to_Friends_2">Talking to Friends 2</h2>
<p>Back to friends, I’ll omit two actions because they’re extremely dependant on how I’ve coded the <em>FriendMeetingPoint</em> entity: <em>attachTo</em>, which attaches the NPC to the <em>FriendMeetingPoint</em> entity and <em>anyAroundAttached</em>, which looks for a friendly NPC that is also attached to a <em>FriendMeetingPoint</em> entity. The subtree now looks like this:</p>
<img src="/images/friend-talk-attach.png" class="center">

<p>The <em>WaitUntil</em> decorator waits until the child node returns success before it can return success. This means that once an entity is attached to a <em>FriendMeetingPoint</em>, it’ll stay there until some other NPC comes along to talk to it.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">WaitUntil = Decorator:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">WaitUntil:new</span><span class="params">(behavior)</span></span></div><div class="line">    WaitUntil.super.new(self, <span class="string">'WaitUntil'</span>, behavior)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">WaitUntil:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> WaitUntil.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">WaitUntil:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">local</span> status = self.behavior:update(dt, context)</div><div class="line">    <span class="keyword">if</span> status == <span class="string">'success'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'success'</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'running'</span> <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">WaitUntil:start</span><span class="params">(context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">WaitUntil:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>After this we add one more action before the actual <em>talk</em> action, which is <em>separate</em>. In case two NPCs attach themselves to the same <em>FriendMeetingPoint</em> we want to separate them a bit before they start talking, otherwise it looks a little too weird. The <em>separate</em> action uses the separation steering behavior that the entities in my game have, so it’s pretty simple code wise:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">separate = Action:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">separate:new</span><span class="params">(radius)</span></span></div><div class="line">    separate.super.new(self, <span class="string">'separate'</span>)</div><div class="line">  </div><div class="line">    self.radius = radius</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">separate:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> separate.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">separate:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> <span class="string">'success'</span>   </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">separate:start</span><span class="params">(context)</span></span></div><div class="line">    context.object:separationOn(self.radius)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">separate:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>And finally we add the <em>talk</em> action, which contains most of the work:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">talk = Action:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">talk:new</span><span class="params">(talk_duration)</span></span></div><div class="line">    talk.super.new(self, <span class="string">'talk'</span>)</div><div class="line">  </div><div class="line">    self.talk_duration = talk_duration</div><div class="line">    self.done = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">talk:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> talk.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">talk:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">if</span> self.done <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'success'</span></div><div class="line">    <span class="keyword">else</span> </div><div class="line">        <span class="keyword">if</span> context.any_around_attached_entity <span class="keyword">then</span></div><div class="line">            context.object:turnTowards(context.any_around_attached_entity)</div><div class="line">        <span class="keyword">end</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'running'</span> </div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">talk:start</span><span class="params">(context)</span></span></div><div class="line">    <span class="comment">-- Timers so that they start talking slightly after they turn towards </span></div><div class="line">    <span class="comment">-- each other, more precisely 0.5 seconds after. Similarly, set a </span></div><div class="line">    <span class="comment">-- timer so that this entity stops talking after the talk duration </span></div><div class="line">    <span class="comment">-- and so that this node returns success (self.done).</span></div><div class="line">    context.object.timer:after(<span class="number">0.5</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> </div><div class="line">        context.object:setTalking(self.talk_duration - <span class="number">1</span>) </div><div class="line">    <span class="keyword">end</span>)</div><div class="line">    context.object.timer:after(<span class="number">0.5</span> + self.talk_duration - <span class="number">1</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> </div><div class="line">        context.object:stopTalking() </div><div class="line">    <span class="keyword">end</span>)</div><div class="line">    context.object.timer:after(self.talk_duration, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> </div><div class="line">        self.done = <span class="keyword">true</span> </div><div class="line">    <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">talk:finish</span><span class="params">(status, context)</span></span></div><div class="line">    <span class="comment">-- Normal clean up...</span></div><div class="line">    self.done = <span class="keyword">false</span></div><div class="line">    context.any_around_attached_entity = <span class="keyword">nil</span></div><div class="line">    context.object.attached_to = <span class="keyword">nil</span></div><div class="line">    <span class="comment">-- Turn the separation behavior off here!</span></div><div class="line">    context.object:separationOff()</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>With this, NPCs should move around randomly, find boxes and lift them with their TK sometimes, and whenever they get close to a <em>FriendMeetingPoint</em> they’ll go there to try to talk to someone. There’s the possibility they’ll be stuck there forever if no one shows up, but that’s a detail that can be fixed by adding a time limit to the <em>WaitUntil</em> decorator for instance. Other than that we have a working implementation of an idle behavior for a particular NPC of this game. It wasn’t super simple but to me at least it beats the approach I was taking before! (which was just hardcoding everything)</p>
<img src="/images/talk4.gif" class="center">

<p>The whole tree now looks like this:</p>
<img src="/images/idle-done.png" class="center">

<p>And the code:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">self.behavior_tree = Root(self,</div><div class="line">    Selector(<span class="string">'idle'</span>, {</div><div class="line">        Sequence(<span class="string">'TK practice'</span>, {</div><div class="line">            findAndMoveTo({<span class="string">'Box'</span>}, <span class="number">50</span>),</div><div class="line">            tkLift(),</div><div class="line">        }),</div><div class="line">  </div><div class="line">        Sequence(<span class="string">'friend talk'</span>, {</div><div class="line">            findAndMoveTo({<span class="string">'FriendMeetingPoint'</span>}, <span class="number">100</span>),</div><div class="line">            attachTo(<span class="string">'FriendMeetingPoint'</span>, <span class="number">10</span>),</div><div class="line">            WaitUntil(anyAroundAttached(<span class="string">'Student'</span>, <span class="string">'FriendMeetingPoint'</span>, <span class="number">80</span>)),</div><div class="line">            separate(<span class="number">10</span>),</div><div class="line">            talk(<span class="number">5</span>),</div><div class="line">        }),</div><div class="line">  </div><div class="line">        Sequence(<span class="string">'wander'</span>, {</div><div class="line">            findWanderPoint(self.x, self.y, <span class="number">100</span>),</div><div class="line">            moveToPoint(),</div><div class="line">            wait(<span class="number">5</span>),</div><div class="line">        })</div><div class="line">    })</div><div class="line">)</div><div class="line">...</div></pre></td></tr></table></figure>

<h2 id="Suspicious">Suspicious</h2>
<p>Now that the idle subtree is done we can move on to the suspicious behavior. This behavior will check to see if the player is around, if it is then it will set the NPC to be suspicious, which will turn him towards the player, change his animation to combat mode and spawn a little question mark above his head. This lasts a few seconds, after which we perform another check to see if the player is still inside the suspicious trigger area, if he is, then we bail out of the sequence and fail, and if he isn’t then we set the NPC back to normal using an unsuspicious action.</p>
<p>The subtree should look like this:</p>
<img src="/images/suspicious.png" class="center">

<p>I’m going to omit the specifis of each behavior since by now you should have a good idea of how I’m coding them and how you’re coding them. If you’re following along and trying this out with your game your tree may look slightly different based on how you’ve coded each behavior, but that just happens, since there are multiple ways of achieving the same thing. In any case, the whole tree should look like this:</p>
<img src="/images/suspicious-tree.png" class="center">

<p>We tie everything up with a selector at the top and by placing the suspicious behavior to the left. We want the tree to first check for any suspicious activity around, and then if that fails, be able to go to idle stuff. The code looks like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">self.behavior_tree = Root(self,</div><div class="line">    Selector(<span class="string">'meleeEnemy'</span>, {</div><div class="line">        Sequence(<span class="string">'suspicious'</span>, {</div><div class="line">            anyAround({<span class="string">'Player'</span>}, <span class="number">150</span>),</div><div class="line">            suspicious(),</div><div class="line">            Inverter(anyAround({<span class="string">'Player'</span>}, <span class="number">150</span>)),</div><div class="line">            unsuspicious(),</div><div class="line">        }),</div><div class="line">  </div><div class="line">        Selector(<span class="string">'idle'</span>, {</div><div class="line">            Sequence(<span class="string">'TK practice'</span>, {</div><div class="line">                findAndMoveTo({<span class="string">'Box'</span>}, <span class="number">50</span>),</div><div class="line">                tkLift(),</div><div class="line">            }),</div><div class="line">  </div><div class="line">            Sequence(<span class="string">'friend talk'</span>, {</div><div class="line">                findAndMoveTo({<span class="string">'FriendMeetingPoint'</span>}, <span class="number">100</span>),</div><div class="line">                attachTo(<span class="string">'FriendMeetingPoint'</span>, <span class="number">10</span>),</div><div class="line">                WaitUntil(anyAroundAttached(<span class="string">'Student'</span>, <span class="string">'FriendMeetingPoint'</span>, <span class="number">80</span>)),</div><div class="line">                separate(<span class="number">10</span>),</div><div class="line">                talk(<span class="number">5</span>),</div><div class="line">            }),</div><div class="line">  </div><div class="line">            Sequence(<span class="string">'wander'</span>, {</div><div class="line">                findWanderPoint(self.x, self.y, <span class="number">100</span>),</div><div class="line">                moveToPoint(),</div><div class="line">                wait(<span class="number">5</span>),</div><div class="line">            })</div><div class="line">        })</div><div class="line">    })</div><div class="line">)</div><div class="line">...</div></pre></td></tr></table></figure>

<img src="/images/susp3.gif" class="center">

<p>As you can see on that gif though, there’s a problem here. Whenever the player enters the suspicious trigger area (yellow circle), the NPC doesn’t become suspicious immediately. This is because he’s still waiting for the <em>wait</em> action to be finished on the idle subtree, which means that he won’t check the suspicious subtree until it ends. We want it to check this immediately, as soon as it happens, but using a normal selector that won’t be possible.</p>
<h2 id="Active_Selector">Active Selector</h2>
<p>An active selector behaves like a selector, except instead of returning to the node that is still running, it always checks all children. So in our case whenever <em>wait</em> returns ‘running’, on the next frame, instead of just going directly to that node and running it again, it will run the suspicious subtree first, see if it returned running or failure, and then move on to the idle subtree where it will pick up from the running <em>wait</em> node. If suspicious succeeds, however, since it behaves like a selector it won’t run the idle subtree.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ActiveSelector = Behavior:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActiveSelector:new</span><span class="params">(name, behaviors)</span></span></div><div class="line">    ActiveSelector.super.new(self)</div><div class="line">    self.name = name</div><div class="line">    self.behaviors = behaviors</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActiveSelector:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> ActiveSelector.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActiveSelector:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="comment">-- Logic is exactly the same as a normal selector, except instead </span></div><div class="line">    <span class="comment">-- of keeping track of which behavior we're in by using current_behavior, </span></div><div class="line">    <span class="comment">-- we just don't do it at all and go through them all every frame.</span></div><div class="line">    <span class="keyword">for</span> _, behavior <span class="keyword">in</span> <span class="built_in">ipairs</span>(self.behaviors) <span class="keyword">do</span></div><div class="line">        <span class="keyword">local</span> status = behavior:update(dt, context)</div><div class="line">        <span class="keyword">if</span> status ~= <span class="string">'failure'</span> <span class="keyword">then</span> <span class="keyword">return</span> status <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'failure'</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActiveSelector:start</span><span class="params">(context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActiveSelector:finish</span><span class="params">(status, context)</span></span></div><div class="line">    </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>And now it should behave accordingly because it will always first check the suspicious subtree (since it’s first on the list). Note that this is, in a way, parallelism. Although isn’t real because it’s doing each in sequence, for the purposes of the tree it is real, since what matters is what happens over multiple frames, and this makes it so that things happen in one frame simultaneously. For the threatened subtree I’ll introduce yet another node called the Parallel, which does something similar to the active selector but has different success/failure logic.</p>
<img src="/images/susp4.gif" class="center">

<h2 id="Threatened">Threatened</h2>
<p>For the threatened behavior the same active selector logic will apply. We need the NPC to be threatened immediately when the Player comes too close. Similarly to <em>suspicious</em>, we’ll use <em>anyAround</em> for this:</p>
<img src="/images/threatened-1.png" class="center">

<img src="/images/threat3.gif" class="center">

<p>Now what we wanna do is make it so that when the NPC is threatened, it chases the player around and tries to hit him if it gets close enough. One way of doing that is, after the <em>threatened</em> node, add a subtree that repeatedly chases and tries to hit the player while doing so:</p>
<img src="/images/attack.png" class="center">

<p><em>repeatUntilFail</em> will make it so that this whole sequence of checking to see if the player is still close and then chasing/punching is repeated forever, which means the NPC will chase the player until he distances himself enough. After that, the only node we don’t really know anything about (assuming the implementation of <em>chase</em> and <em>meleeAttack</em>) is the Parallel one.</p>
<p>The implementation of the parallel node is probably one of the most complex ones, but it’s similar to the active selector in the sense that it always goes through all nodes. The only difference is that on top of receiving behaviors as arguments it can also receive failure and success policies. A failure policy defines when the parallel node will fail, same for the success one. Both types of policies have two possible values: ‘one’ or ‘all’. An ‘one’ failure policy means that the parallel node will fail whenever one of its nodes fail. An ‘all’ success policy means that the parallel node will succeed only when all of its children succeed, and so on… </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">Parallel = Behavior:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:new</span><span class="params">(name, success_policy, failure_policy, behaviors)</span></span></div><div class="line">    Parallel.super.new(self)</div><div class="line">    self.name = name</div><div class="line">    self.success_policy = success_policy</div><div class="line">    self.failure_policy = failure_policy</div><div class="line">    self.behaviors = behaviors</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> Parallel.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">local</span> success_count, failure_count = <span class="number">0</span>, <span class="number">0</span> </div><div class="line">    <span class="keyword">for</span> _, behavior <span class="keyword">in</span> <span class="built_in">ipairs</span>(self.behaviors) <span class="keyword">do</span></div><div class="line">        <span class="keyword">local</span> status = <span class="keyword">nil</span></div><div class="line">        status = behavior:update(dt, context)</div><div class="line">   </div><div class="line">        <span class="keyword">if</span> status == <span class="string">'success'</span> <span class="keyword">then</span></div><div class="line">            success_count = success_count + <span class="number">1</span></div><div class="line">            behavior:finish(status, context)</div><div class="line">            <span class="comment">-- Got one success and the success policy only requires one, so succeed</span></div><div class="line">            <span class="comment">-- same for failure in the next if statement.</span></div><div class="line">            <span class="keyword">if</span> self.success_policy == <span class="string">'one'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'success'</span> <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">  </div><div class="line">        <span class="keyword">if</span> status == <span class="string">'failure'</span> <span class="keyword">then</span></div><div class="line">            failure_count = failure_count + <span class="number">1</span></div><div class="line">            behavior:finish(status, context)</div><div class="line">            <span class="keyword">if</span> self.failure_policy == <span class="string">'one'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'failure'</span> <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  </div><div class="line">    <span class="comment">-- Has been through all behaviors, the failure/success policy is 'all' </span></div><div class="line">    <span class="comment">-- and the number ofbehaviors matches the failure/success count? </span></div><div class="line">    <span class="comment">-- Then fail/succeed!</span></div><div class="line">    <span class="keyword">if</span> self.failure_policy == <span class="string">'all'</span> <span class="keyword">and</span> failure_count == #self.behaviors <span class="keyword">then</span> </div><div class="line">        <span class="keyword">return</span> <span class="string">'failure'</span> </div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">if</span> self.success_policy == <span class="string">'all'</span> <span class="keyword">and</span> success_count == #self.behaviors <span class="keyword">then</span> </div><div class="line">        <span class="keyword">return</span> <span class="string">'success'</span> </div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'running'</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:start</span><span class="params">(context)</span></span></div><div class="line">      </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:finish</span><span class="params">(status, context)</span></span></div><div class="line">    <span class="comment">-- If the parallel node is done, finish all currently running behaviors so that </span></div><div class="line">    <span class="comment">-- the next time the node is run it starts over instead of continuing </span></div><div class="line">    <span class="comment">-- the previous run.</span></div><div class="line">    <span class="keyword">for</span> _, behavior <span class="keyword">in</span> <span class="built_in">ipairs</span>(self.behaviors) <span class="keyword">do</span></div><div class="line">        <span class="keyword">if</span> behavior.status == <span class="string">'running'</span> <span class="keyword">then</span></div><div class="line">            behavior:finish(status, context)</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>For the attack subtree we used (‘all’, ‘all’), which means that we want it to fail or succeed whenever both behaviors fail or succeed, which is rare. <em>chase</em> always succeeds. <em>anyAround</em> can fail if the player is far away enough from the NPC. <em>meleeAttack</em> always succeeds. Whenever they all succeed, the parallel node will succeed, which means the sequence will succeed, which will return success to <em>repeatUntilFail</em>, meaning that the whole subtree will be repeated again. The only way out of this subtree is if the first <em>anyAround</em> outside of the parallel node fails, which is the intended behavior.</p>
<p>And with that we have a working attacking enemy! The code for the whole tree now looks like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">self.behavior_tree = Root(self,</div><div class="line">    ActiveSelector(<span class="string">'meleeEnemy'</span>, {</div><div class="line">        Sequence(<span class="string">'attack'</span>, {</div><div class="line">            anyAround({<span class="string">'Player'</span>}, <span class="number">75</span>),</div><div class="line">            threatened(),</div><div class="line">            RepeatUntilFail(Sequence(<span class="string">'chase'</span>, {</div><div class="line">                anyAround({<span class="string">'Player'</span>}, <span class="number">75</span>),</div><div class="line">                Parallel(<span class="string">'chaseAttack'</span>, <span class="string">'all'</span>, <span class="string">'all'</span>, {</div><div class="line">                    chase(),</div><div class="line">                    Sequence(<span class="string">'attack'</span>, {</div><div class="line">                        anyAround({<span class="string">'Player'</span>}, <span class="number">30</span>),</div><div class="line">                        meleeAttack(),</div><div class="line">                    }),</div><div class="line">                }),</div><div class="line">            })),</div><div class="line">            Inverter(anyAround({<span class="string">'Player'</span>}, <span class="number">75</span>)),</div><div class="line">            unthreatened(),</div><div class="line">        }),</div><div class="line">  </div><div class="line">        Sequence(<span class="string">'suspicious'</span>, {</div><div class="line">            anyAround({<span class="string">'Player'</span>}, <span class="number">150</span>),</div><div class="line">            suspicious(),</div><div class="line">            Inverter(anyAround({<span class="string">'Player'</span>}, <span class="number">150</span>)),</div><div class="line">            unsuspicious(),</div><div class="line">        }),</div><div class="line">  </div><div class="line">        Selector(<span class="string">'idle'</span>, {</div><div class="line">            Sequence(<span class="string">'TK practice'</span>, {</div><div class="line">                findAndMoveTo({<span class="string">'Box'</span>}, <span class="number">50</span>),</div><div class="line">                tkLift(),</div><div class="line">            }),</div><div class="line">  </div><div class="line">            Sequence(<span class="string">'friend talk'</span>, {</div><div class="line">                findAndMoveTo({<span class="string">'FriendMeetingPoint'</span>}, <span class="number">100</span>),</div><div class="line">                attachTo(<span class="string">'FriendMeetingPoint'</span>, <span class="number">10</span>),</div><div class="line">                WaitUntil(anyAroundAttached(<span class="string">'Student'</span>, <span class="string">'FriendMeetingPoint'</span>, <span class="number">80</span>)),</div><div class="line">                separate(<span class="number">10</span>),</div><div class="line">                talk(<span class="number">5</span>),</div><div class="line">            }),</div><div class="line">  </div><div class="line">            Sequence(<span class="string">'wander'</span>, {</div><div class="line">                findWanderPoint(self.x, self.y, <span class="number">100</span>),</div><div class="line">                moveToPoint(),</div><div class="line">                wait(<span class="number">5</span>),</div><div class="line">            })</div><div class="line">        })</div><div class="line">    })</div><div class="line">)</div><div class="line">...</div></pre></td></tr></table></figure>

<p>And the final tree looks like this:</p>
<img src="/images/final-tree.png" class="center">

<img src="/images/fight.gif" class="center">

<h2 id="END">END</h2>
<p>And that’s it! If you’ve followed through all this, even if just reading the explanations and code, you should have a nice idea of what behavior trees can do and how they do it. Hopefully this helped you in ways that I wanted to be helped when I was trying to understand all this. There are tons of issues with the way I’m doing it and there are tons of resources that go beyond what my implementation does, but since my game isn’t really memory nor performance intensive I can get away with the simple solution. The resources on the first paragraph of the first part mostly cover these issues.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This tutorial features a full implementation of behavior for an enemy using behavior trees]]>
    
    </summary>
    
      <category term="ai" scheme="http://psychoky.me/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Behavior Trees #1]]></title>
    <link href="http://psychoky.me/2014/08/16/behavior-trees-number-1/"/>
    <id>http://psychoky.me/2014/08/16/behavior-trees-number-1/</id>
    <published>2014-08-17T00:05:00.000Z</published>
    <updated>2015-01-09T07:17:08.000Z</updated>
    <content type="html"><![CDATA[<p>This post explains behavior trees as I understood them<a id="more"></a>. There are very few behavior tree related tutorials out there that have both code examples as well as concise explanations. The best ones I could find are <a href="https://www.youtube.com/watch?v=n4aREFb3SsU" target="_blank" rel="external">here</a> and <a href="http://aigamedev.com/insider/presentations/behavior-trees/" target="_blank" rel="external">here</a>, and while they’re really good, when going through them I surely had many doubts that the lack of other decent tutorials didn’t help answering. With that in mind, this article provides another source that people can use as a reference as they learn about behavior trees. Part 1 (this one) will deal with explaining what behavior trees are and how you can implement them, while Part 2 will use them to build a simple yet complete enemy behavior. Most of the code used here uses <a href="https://github.com/aigamedev/btsk" target="_blank" rel="external">this</a> one as a reference with some slight changes. And I learned about behavior trees initially from <a href="http://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php" target="_blank" rel="external">this</a> article! Give it a quick read first, since I think it does a better job at explaining the basics than I do here.</p>
<h2 id="Introduction">Introduction</h2>
<p>Behavior Trees are used to describe the behavior of entities in a game in a hopefully intuitive manner. They do this by using the following definitions:</p>
<ul>
<li>A tree is composed of nodes (like the normal tree data structure would);</li>
<li>A node can run some operation and then return the status of that operation to its parent;</li>
<li>Three statuseses are usually used: success, failure and running.</li>
</ul>
<p>With these three simple rules a lot can be done. For instance:</p>
<img src="/images/root-movetopoint.png" class="center">

<p>That tree is added to an entity like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entity:new</span><span class="params">(...)</span></span></div><div class="line">    ...</div><div class="line">    self.behavior_tree = Root(self, moveToPoint())</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entity:update</span><span class="params">(dt)</span></span></div><div class="line">    self.behavior_tree:update(dt)</div><div class="line"><span class="keyword">end</span></div><div class="line">...</div></pre></td></tr></table></figure>

<p>And so the <em>moveToPoint</em> behavior, which finds a point for the entity to move to and then moves it there, will be run every frame. moveToPoint returns <strong>success</strong> whenever the entity gets close enough to the target point, <strong>running</strong> when it’s moving there and <strong>failure</strong> when it’s stuck around some area for more than a few seconds. In this way, this single behavior can take place along multiple frames (whenever it’s returning <em>running</em>) and also deals with failure nicely. </p>
<p>This ability is what makes behavior trees an attractive choice for handling AI. Failure and actions over multiple frames are kind of what makes AI coding somewhat of a pain and usually degenerates into a bunch of ifs or huge switches or some other not that clean structure. Offloading all that complexity to behavior trees (which are basically doing all those ifs in their structure) and making it so that actions are coded in a safe environment with an extremely well defined interface (success, failure, running) makes everything easier. On top of that it’s possible that the composability of actions and subtrees makes it easier to reuse code, although I haven’t used BTs for too long to see if that’s true or not for myself, but it totally seems to be so far.</p>
<h2 id="Behavior">Behavior</h2>
<p>Before anything else we’re going to do the base node/behavior class. It’s pretty simple and looks like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Behavior = mg.Class:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Behavior:new</span><span class="params">()</span></span></div><div class="line">    self.status = <span class="string">'invalid'</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Behavior:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">if</span> self.status ~= <span class="string">'running'</span> <span class="keyword">then</span> self:start(context) <span class="keyword">end</span></div><div class="line">    self.status = self:run(dt, context)</div><div class="line">    <span class="keyword">if</span> self.status ~= <span class="string">'running'</span> <span class="keyword">then</span> self:finish(self.status, context) <span class="keyword">end</span></div><div class="line">    <span class="keyword">return</span> self.status </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>The constructor initializes this node’s status to some invalid value and the update function runs the <em>start</em>, <em>run</em> and <em>finish</em> functions and returns its status. <em>start</em> and <em>finish</em> are run only if the current status isn’t <em>running</em>, which makes sense, since anything else implies the node hasn’t been started or has finished already. You’ll note that there’s a context variable being passed around. This will be the shared space for which all nodes in the tree can write to and read from. It’s a way nodes have of communicating with each other and is just a table created at the top most node, the Root.</p>
<h2 id="Root">Root</h2>
<p>The root node is the top most node of all behavior trees and is simply there because we need to store tree-wide data somewhere, such as the context.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Root = Behavior:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Root:new</span><span class="params">(object, behavior)</span></span></div><div class="line">    Root.super.new(self)</div><div class="line">    self.behavior = behavior</div><div class="line">    self.object = object</div><div class="line">    self.context = {object = self.object}</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Root:update</span><span class="params">(dt)</span></span></div><div class="line">    <span class="keyword">return</span> Root.super.update(self, dt)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Root:run</span><span class="params">(dt)</span></span></div><div class="line">    <span class="keyword">return</span> self.behavior:update(dt, self.context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Root:start</span><span class="params">()</span></span></div><div class="line">    self.context = {object = self.object}</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Root:finish</span><span class="params">(status)</span></span></div><div class="line">    </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>A root node inherits from the previous Behavior class. For its constructor, since each behavior tree is gonna be attached to an entity, it takes that entity as well as a single behavior as arguments. In the update function it calls Behavior’s update function, which calls Root’s <em>start</em>, <em>run</em> and <em>finish</em> functions depending on its status and the returned value from <em>run</em>. Root’s run function, where the heart of its behavior lies, simply calls the attached behavior’s update function, which translates to it going down and starting to explore the tree. That behavior/node, unless it’s a leaf node like <em>moveToPoint</em> was, will also somehow call its behavior’s update functions and so on. This means that each frame the whole tree is being explored, starting from the root node and going down according to the logic of each subsequent one. Finally, root’s start function starts the context and adds the object this tree is attached to to the <em>object</em> field. Nodes down the tree will then be able to access the object by saying <em>context.object</em>.</p>
<h2 id="Action">Action</h2>
<p>An action is a leaf node that will perform some… action. This action can be either be a conditional question that changes the context with some information, for instance, or just a normal action like <em>moveToPoint</em>.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Action = Behavior:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Action:new</span><span class="params">(name)</span></span></div><div class="line">    Action.super.new(self)</div><div class="line">    self.name = name <span class="keyword">or</span> <span class="string">'Action'</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Action:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> Action.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>To be honest this class probably didn’t even need to exist, but like the Root node it inherits from Behavior. The only meaningful change is that it takes in a name so that it can be identified (when debugging for instance). To create a new Action we need to inherit from it like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">newAction = Action:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newAction:new</span><span class="params">()</span></span></div><div class="line">    newAction.super.new(self, <span class="string">'newAction'</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newAction:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> newAction.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newAction:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="comment">-- newAction's behavior goes here</span></div><div class="line">    <span class="comment">-- should return 'success', 'running' or 'failure'</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newAction:start</span><span class="params">(context)</span></span></div><div class="line">    <span class="comment">-- any setup goes here</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newAction:finish</span><span class="params">(status, context)</span></span></div><div class="line">    <span class="comment">-- any cleanup goes here</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>The constructor and the update functions call Action’s constructor and update functions, similarly to Root, but then the <em>run</em>, <em>start</em> and <em>finish</em> functions are where the functionality of the new action will go.</p>
<h2 id="Sequence">Sequence</h2>
<img src="/images/sequence-failure.png" class="center">

<img src="/images/sequence-success.png" class="center">

<p>A sequence is a composite node (it can have multiple children) that performs each of its children in sequence. If one child fails then the whole sequence fails, but if one child succeeds then the sequence moves on to the next. If all children succeed then the sequence succeeds. If a child is still running then the sequence returns running as well and on the next frame it will come back to that running node.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Sequence = Behavior:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:new</span><span class="params">(name, behaviors)</span></span></div><div class="line">    Sequence.super.new(self)</div><div class="line">    self.name = name</div><div class="line">    self.behaviors = behaviors</div><div class="line">    self.current_behavior = <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> Sequence.super.update(self, dt, context) </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span></div><div class="line">        <span class="keyword">local</span> status = self.behaviors[self.current_behavior]:update(dt, context)</div><div class="line">        <span class="keyword">if</span> status ~= <span class="string">'success'</span> <span class="keyword">then</span> <span class="keyword">return</span> status <span class="keyword">end</span></div><div class="line">        self.current_behavior = self.current_behavior + <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> self.current_behavior == ##self.behaviors + <span class="number">1</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'success'</span> <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:start</span><span class="params">(context)</span></span></div><div class="line">    self.current_behavior = <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>A sequence takes in a name and multiple behaviors. The update function is as usual and the start function sets the current behavior to be the first. The run function then does the work of going through all behaviors if they return <em>success</em>, or returning <em>running</em> or <em>failure</em> if any behavior returns that. Note that if a node returns <em>running</em>, on the next frame it will return to that node because <em>current_behavior</em> will be set there. If on every frame <em>current_behavior</em> was set to one (1), for instance, the sequence would only ever succeed if all nodes succeeded on this frame, but it would also not fail when <em>running</em> was returned, it would just lose the ability to do the sequence over multiple frames. </p>
<h2 id="Selector">Selector</h2>
<img src="/images/selector-failure.png" class="center">

<img src="/images/selector-success.png" class="center">

<p>A selector is another composite node that performs each of its children in sequence, however, unlike a Sequence, it succeeds if any one of its children succeeds, and fails only if all children fail. Whenever a single node fails then it moves on to the next and tries it, if that fails, it goes on to the next until one succeeds or returns <em>running</em>. Similarly to a Sequence, <em>running</em> will also make the Selector come back to the running node on the next frame.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Selector = Behavior:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:new</span><span class="params">(name, behaviors)</span></span></div><div class="line">    Selector.super.new(self)</div><div class="line">    self.name = name</div><div class="line">    self.behaviors = behaviors </div><div class="line">    self.current_behavior = <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> Selector.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span></div><div class="line">        <span class="keyword">local</span> status = self.behaviors[self.current_behavior]:update(dt, context)</div><div class="line">        <span class="keyword">if</span> status ~= <span class="string">'failure'</span> <span class="keyword">then</span> <span class="keyword">return</span> status <span class="keyword">end</span></div><div class="line">        self.current_behavior = self.current_behavior + <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> self.current_behavior == ##self.behaviors + <span class="number">1</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'failure'</span> <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:start</span><span class="params">(context)</span></span></div><div class="line">    self.current_behavior = <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>The logic is pretty much the same as a Sequence, just reversed. </p>
<h2 id="Decorator">Decorator</h2>
<img src="/images/decorator.png" class="center">

<p>A decorator is a node that can only have one child and that performs some logic to change the result returned from that single child.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Decorator = Behavior:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Decorator:new</span><span class="params">(name, behavior)</span></span></div><div class="line">    Decorator.super.new(self)</div><div class="line">    self.name = name</div><div class="line">    self.behavior = behavior</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Decorator:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> Decorator.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>The class for it, like an Action, is just a stub that is supposed to be inherited from when you create an actual decorator. It takes in a name and the to be attached behavior. A common decorator is the Inverter, which takes the value from the child and inverts it:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Inverter = Decorator:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Inverter:new</span><span class="params">(behavior)</span></span></div><div class="line">    Inverter.super.new(self, <span class="string">'Inverter'</span>, behavior)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Inverter:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> Inverter.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Inverter:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">local</span> status = self.behavior:update(dt, context)</div><div class="line">    <span class="keyword">if</span> status == <span class="string">'running'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'running'</span></div><div class="line">    <span class="keyword">elseif</span> status == <span class="string">'success'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'failure'</span></div><div class="line">    <span class="keyword">elseif</span> status == <span class="string">'failure'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'success'</span> <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Inverter:start</span><span class="params">(context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Inverter:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>The constructor and update functions are as always, and the run function, which has the meat of the inversion behavior, runs the attached behavior’s update function, takes its returned value and then returns <em>failure</em> if it succeed, <em>success</em> if it failed, and <em>running</em> if its still running. Another useful decorator is RepeatUntilFail, which has a run function that looks like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">RepeatUntilFail = Decorator:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">RepeatUntilFail:new</span><span class="params">(behavior)</span></span></div><div class="line">    RepeatUntilFail.super.new(self, <span class="string">'RepeatUntilFail'</span>, behavior)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">RepeatUntilFail:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> RepeatUntilFail.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">RepeatUntilFail:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">local</span> status = self.behavior:update(dt, context)</div><div class="line">    <span class="keyword">if</span> status ~= <span class="string">'failure'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'running'</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'success'</span> <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">RepeatUntilFail:start</span><span class="params">(context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">RepeatUntilFail:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>Another one is a timer, that runs the child node after a certain amount of time has passed:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Timer = Decorator:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer:new</span><span class="params">(name, duration, behavior)</span></span></div><div class="line">    Timer.super.new(self, name, behavior)</div><div class="line">    self.duration = duration</div><div class="line">    self.ready_to_run = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> Timer.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">if</span> self.ready_to_run <span class="keyword">then</span></div><div class="line">        <span class="keyword">local</span> status = self.behavior:update(dt, context)</div><div class="line">        <span class="keyword">return</span> status</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'running'</span> <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer:start</span><span class="params">(context)</span></span></div><div class="line">    self.ready_to_run = <span class="keyword">false</span></div><div class="line">    mg.timer:after(self.duration, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> self.ready_to_run = <span class="keyword">true</span> <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer:finish</span><span class="params">(status, context)</span></span></div><div class="line">    self.ready_to_run = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>Here <em>mg.timer</em> is the timer module, and <em>:after</em> simply makes it so that the function passed gets called <em>n</em> seconds after this point. So this decorator will be <em>ready_to_run</em> after <em>duration</em> seconds have passed from when it first started, and when that happens it will run and return the returned value from its child.</p>
<h2 id="Example">Example</h2>
<p>Now let’s build a ~real~ tree and attach it to a ~real~ entity. The idea is to make the entity move around randomly by using two actions: <em>findWanderPoint</em>, which finds a point for the entity to move to and adds it to the context, and <em>moveToPoint</em>, which moves the entity to that point. <em>findWanderPoint</em> needs to receive a point and a radius where it can look around for a new point and so it would look like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">findWanderPoint = Action:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findWanderPoint:new</span><span class="params">(x, y, radius)</span></span></div><div class="line">    findWanderPoint.super.new(self, <span class="string">'findWanderPoint'</span>)</div><div class="line">  </div><div class="line">    self.x = x</div><div class="line">    self.y = y</div><div class="line">    self.radius = radius</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findWanderPoint:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> findWanderPoint.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findWanderPoint:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="comment">-- Find a point in a circle centered in x, y with radius radius</span></div><div class="line">    <span class="keyword">local</span> angle = mg.utils.<span class="built_in">math</span>.random(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">math</span>.pi)</div><div class="line">    <span class="keyword">local</span> distance = mg.utils.<span class="built_in">math</span>.random(<span class="number">0</span>, self.radius)</div><div class="line">    <span class="comment">-- Add that point to the context so that it can be accessed </span></div><div class="line">    <span class="comment">-- later by the moveToPoint action</span></div><div class="line">    context.move_to_point_target = mg.Vector(self.x + distance*<span class="built_in">math</span>.cos(angle), </div><div class="line">                                             self.y + distance*<span class="built_in">math</span>.sin(angle))</div><div class="line">    <span class="keyword">return</span> <span class="string">'success'</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findWanderPoint:start</span><span class="params">(context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findWanderPoint:finish</span><span class="params">(status, context)</span></span></div><div class="line">  </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>And <em>moveToPoint</em> like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">moveToPoint = Action:extend()</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveToPoint:new</span><span class="params">()</span></span></div><div class="line">    moveToPoint.super.new(self, <span class="string">'moveToPoint'</span>)</div><div class="line">  </div><div class="line">    self.last_position = mg.Vector(<span class="number">0</span>, <span class="number">0</span>)</div><div class="line">    self.stuck = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveToPoint:update</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="keyword">return</span> moveToPoint.super.update(self, dt, context)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveToPoint:run</span><span class="params">(dt, context)</span></span></div><div class="line">    <span class="comment">-- Fail if stuck</span></div><div class="line">    <span class="keyword">if</span> self.stuck <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'failure'</span> <span class="keyword">end</span></div><div class="line">    <span class="comment">-- Check distance to target point, if roughly there then succeed,</span></div><div class="line">    <span class="comment">-- otherwise return running, which means the entity is moving there.</span></div><div class="line">    <span class="comment">-- In the off chance move_to_point_target isn't set then fail.</span></div><div class="line">    <span class="keyword">if</span> context.move_to_point_target <span class="keyword">then</span></div><div class="line">        <span class="keyword">local</span> distance = context.move_to_point_target:dist(</div><div class="line">                         mg.Vector(context.object.body:getPosition()))</div><div class="line">        <span class="keyword">if</span> distance &lt; <span class="number">10</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'success'</span></div><div class="line">        <span class="keyword">elseif</span> distance &gt;= <span class="number">10</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">'running'</span> <span class="keyword">end</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'failure'</span> <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveToPoint:start</span><span class="params">(context)</span></span></div><div class="line">    <span class="comment">-- Steering behavior takes care of moving the object towards the target point</span></div><div class="line">    context.object:arriveOn(context.move_to_point_target)</div><div class="line">    self.last_position = mg.Vector(context.object.body:getPosition())</div><div class="line">    <span class="comment">-- Every 4 seconds check to see if the distance to the position of 4 seconds ago</span></div><div class="line">    <span class="comment">-- is still roughly the same. If it is then set self.stuck to true.</span></div><div class="line">    context.object.timer:every(<span class="number">4</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> current_position = mg.Vector(context.object.body:getPosition())</div><div class="line">        <span class="keyword">local</span> distance = current_position:dist(self.last_position)</div><div class="line">        <span class="keyword">if</span> distance &lt; <span class="number">5</span> <span class="keyword">then</span> self.stuck = <span class="keyword">true</span> <span class="keyword">end</span></div><div class="line">        self.last_position = current_position</div><div class="line">    <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveToPoint:finish</span><span class="params">(status, context)</span></span></div><div class="line">    <span class="comment">-- Turn steering behavior off and set the node back to it's initial state,</span></div><div class="line">    <span class="comment">-- as well as removing variables that aren't going to be </span></div><div class="line">    <span class="comment">-- used anymore from the context</span></div><div class="line">    context.object:arriveOff()</div><div class="line">    context.move_to_point_target = <span class="keyword">nil</span></div><div class="line">    self.stuck = <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>And the entity getting this behavior would create the tree like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">-- in said entity's constructor</span></div><div class="line">self.behavior_tree = Root(self,</div><div class="line">    Sequence(<span class="string">'wander'</span>, {</div><div class="line">        findWanderPoint(self.x, self.y, <span class="number">100</span>),</div><div class="line">        moveToPoint(),</div><div class="line">    })</div><div class="line">)</div><div class="line">...</div></pre></td></tr></table></figure>

<p>To bind both actions we’re using a sequence! If for some reason <em>findWanderPoint</em> fails (it can’t do since it always returns ‘success’, but supposing it could), then <em>moveToPoint</em> won’t do anything. Another thing to note is that both actions are now tied together by their use of <em>context.move_to_point_target</em>. This means that any future action that preceeds <em>moveToPoint</em> needs to set <em>context.move_to_point_target</em> to some 2D vector, otherwise it won’t work. These types of dependencies are necessary, even if they may not be ideal. A solution for this is described <a href="">here</a> by using stacks, but IMO that seems like adding too much low level logic to the tree. But if you find it better then who am I to judge I’ve only been using this technique for like a week so yea</p>
<img src="http://puu.sh/aVS8y/7bab5007e6.gif" class="center">
]]></content>
    <summary type="html">
    <![CDATA[<p>This post explains behavior trees as I understood them]]>
    
    </summary>
    
      <category term="ai" scheme="http://psychoky.me/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The Power of Lua and Mixins]]></title>
    <link href="http://psychoky.me/2014/01/07/the-power-of-lua-and-mixins/"/>
    <id>http://psychoky.me/2014/01/07/the-power-of-lua-and-mixins/</id>
    <published>2014-01-07T08:30:00.000Z</published>
    <updated>2015-01-09T04:50:14.000Z</updated>
    <content type="html"><![CDATA[<p>This post deals with OOP and Lua<a id="more"></a>, and since Lua has no OOP built-in by default I’ll make use of a library. <a href="https://github.com/kikito" target="_blank" rel="external">kikito</a> has a <a href="https://github.com/kikito/middleclass" target="_blank" rel="external">great OOP library</a> made for Lua that supports <a href="https://github.com/kikito/middleclass/wiki/Mixins" target="_blank" rel="external">mixins</a>. <a href="https://github.com/rxi" target="_blank" rel="external">rxi</a> also has <a href="https://github.com/rxi/classic" target="_blank" rel="external">one</a> (it’s the one I use now). Either way, as stated in one of those links: <em>“Mixins can be used for sharing methods between classes, without requiring them to inherit from the same father”</em>. If you’ve read anything about component based system design, then you’ve read something like that quote but probably without the word mixin anywhere near it. Since I’ve been using mixins as the foundation of the entity code in Kara, in this post I’ll explain their advantages and what you can possibly get out of them.</p>
<img src="http://i.minus.com/iC0oXxbIOE4zd.gif" class="center">

<h2 id="Objects,_attributes_and_methods_in_Lua">Objects, attributes and methods in Lua</h2>
<p>The one thing to remember about Lua is that everything in it is a table, except the things that aren’t. But pretty much all objects are going to be made out of tables (essentially hash tables) that have attribute and method names as keys and attribute values and functions as values. So, for instance, this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Entity = class(<span class="string">'Entity'</span>)</div><div class="line">  </div><div class="line"><span class="comment">-- This is the constructor!</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entity:init</span><span class="params">(x, y)</span></span></div><div class="line">    self.x = x</div><div class="line">    self.y = y</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line">object = Entity(<span class="number">300</span>, <span class="number">400</span>)</div></pre></td></tr></table></figure>

<p>… is, for all that matters to this post, the same as having a table named <em>object</em> with keys <em>init</em>, <em>x</em> and <em>y</em>.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- in Lua, table.something is the same as table["something"]</span></div><div class="line"><span class="comment">-- so basically accessing a key in a table looks like accessing </span></div><div class="line"><span class="comment">-- an attribute of an object</span></div><div class="line">  </div><div class="line">object = {}</div><div class="line">object[<span class="string">"init"</span>] = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></div><div class="line">    object[<span class="string">"x"</span>] = x</div><div class="line">    object.y = y</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line">object.init(<span class="number">300</span>, <span class="number">400</span>)</div></pre></td></tr></table></figure>

<h2 id="Mixins">Mixins</h2>
<p>If you’ve looked at <a href="https://github.com/kikito/middleclass/wiki/Mixins" target="_blank" rel="external">this mixins explanation</a> it should be pretty clear what’s going on. In case it isn’t: an <em>include</em> call simply adds the defined functions of a certain mixin to a certain class, which means adding a new key to the table that is the object. In a similar fashion, a function that changes an object’s attributes can be defined:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Mixin = {</div><div class="line">    mixinFunctionInit = <span class="function"><span class="keyword">function</span><span class="params">(self, x, y)</span></span></div><div class="line">        self.x = x</div><div class="line">        self.y = y</div><div class="line">    <span class="keyword">end</span></div><div class="line">}</div><div class="line">  </div><div class="line">Entity = class(<span class="string">'Entity'</span>)</div><div class="line">Entity:include(Mixin)</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entity:init</span><span class="params">(x, y)</span></span></div><div class="line">    self:mixinFunctionInit(x, y)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line">object = Entity(<span class="number">300</span>, <span class="number">400</span>)</div></pre></td></tr></table></figure>

<p>This example is exactly the same as the first one up there, except that instead of directly setting the <em>x</em> and <em>y</em> attributes, the mixin does it. The <em>include</em> call adds the <em>mixinFunctionInit</em> function to the class, then calling that function makes changing the object’s attributes possible (by passing self, a reference to the object being modified). It’s a very easy and cheap way of getting some flexibility into your objects. That flexibility can get you the following:</p>
<h2 id="Reusability">Reusability</h2>
<p>Component based systems were mentioned, and mixins are a way of getting there. For instance, these are the initial calls for two classes in Kara, the Hammer and a Blaster (an enemy):</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Hammer = class(<span class="string">'Hammer'</span>, Entity)</div><div class="line">Hammer:include(PhysicsRectangle)</div><div class="line">Hammer:include(Timer)</div><div class="line">Hammer:include(Visual)</div><div class="line">Hammer:include(Steerable)</div><div class="line">...</div><div class="line">  </div><div class="line">Blaster = class(<span class="string">'Blaster'</span>, Entity)</div><div class="line">Blaster:include(Timer)</div><div class="line">Blaster:include(PhysicsRectangle)</div><div class="line">Blaster:include(Steerable)</div><div class="line">Blaster:include(Stats)</div><div class="line">Blaster:include(HittableRed)</div><div class="line">Blaster:include(EnemyExploder)</div><div class="line">...</div></pre></td></tr></table></figure>

<p>Notice how the <em>PhysicsRectangle</em>, <em>Timer</em> and <em>Steerable</em> mixins repeat themselves? That’s reusability in its purest form. <em>PhysicsRectangle</em> is a simple wrapper mixin for LÖVE’s box2d implementation, and, as you may guess, makes it so that the object becomes a physics object of rectangular shape. The <em>Timer</em> mixin implements a wrapper for the main Timer class, containing calls like <em>after</em> (do something after <em>n</em> seconds) or <em>every</em> (do something every <em>n</em> seconds). A bit off-topic, but since you can pass functions as arguments in Lua, timers are pretty nifty and have pretty simple calls that look like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- somewhere in the code of a class that has the Timer mixin</span></div><div class="line"><span class="comment">-- after 2 seconds explode this object by doing everything  needed in an explosion</span></div><div class="line">self.timer:tween(<span class="number">2</span>, self, {tint_color = {<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>}}, <span class="string">'in-out-cubic'</span>)</div><div class="line">self.timer:after(<span class="number">2</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">    self.dead = <span class="keyword">true</span></div><div class="line">    self:createExplosionParticles()</div><div class="line">    self:createDeathParticles()</div><div class="line">    self:dealAreaDamage({radius = <span class="number">10</span>, damage = <span class="number">50</span>})</div><div class="line">    self.world:cameraShake({intensity = <span class="number">5</span>, duration = <span class="number">1</span>})</div><div class="line"><span class="keyword">end</span>)</div></pre></td></tr></table></figure>

<p>Anyway, lastly, the <em>Steerable</em> mixin implements steering behaviors, which are used to control how far and in which way something moves towards a target. With a bit of work steering behaviors can be used in all sorts of ways to achieve basic entity behaviors while allowing for the possibility of more complex ones later on. In any case, those three mixins were reused with changes only to the variables passed in on their initialization and sometimes on their update function. Otherwise, it’s all the same code that can be used by multiple classes. Consider the alternative, where reuse would have to rely on inheritance and somehow Hammer and Blaster would have to be connected in some weird way, even though they’re completely different things (one is something the Player uses as a tool of attack, the other is an Enemy).</p>
<img src="http://i.minus.com/iODyWFd5pXR4b.gif" class="center">

<p>And consider the other alternative, which is the normal component based system. It usually uses some sort of message passing or another mechanism to get variables from other components in<br>the same object (kinda yucky!). While the mixin based system simply changes those attributes directly, because when you’re coding a mixin you always have a reference to the object you’re<br>coding to via the <em>self</em> parameter.</p>
<h2 id="Object_Creation">Object Creation</h2>
<p>The mutability offered by mixins (in this case Lua is also important) also helps when you’re creating objects. For instance, this is the single call that I need to create new objects in my game:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- in the Factory object</span></div><div class="line">create = <span class="function"><span class="keyword">function</span><span class="params">(self, type, x, y, settings)</span></span></div><div class="line">    <span class="built_in">table</span>.insert(self.to_be_created, </div><div class="line">                {<span class="built_in">type</span> = <span class="built_in">type</span>, x = x, y = y, settings = settings})</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="comment">-- Example:</span></div><div class="line">enemy = create(<span class="string">'Enemy'</span>, <span class="number">400</span>, <span class="number">300</span>, {velocity = <span class="number">200</span>, hp = <span class="number">5</span>, damage = <span class="number">2</span>}) </div></pre></td></tr></table></figure>

<p>And then this gets called every frame to create the objects inside the <em>to_be_created</em> list (this must be done because I can’t create objects while box2d runs its own update cycle,<br>and it usually happens that the <em>create</em> function is called precisely while box2d is running):</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">createPostWorldStep = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></div><div class="line">    <span class="keyword">for</span> _, o <span class="keyword">in</span> <span class="built_in">ipairs</span>(self.to_be_created) <span class="keyword">do</span></div><div class="line">        <span class="keyword">local</span> entity = <span class="keyword">nil</span></div><div class="line">        <span class="keyword">if</span> o.<span class="built_in">type</span> <span class="keyword">then</span> entity = <span class="built_in">_G</span>[o.<span class="built_in">type</span>](self, o.x, o.y, o.settings) <span class="keyword">end</span></div><div class="line">        self:add(entity)</div><div class="line">    <span class="keyword">end</span></div><div class="line">    self.to_be_created = {}</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>Essentially, whenever I create a class like this: <em>“Entity = class(‘Entity’)”</em> I’m actually creating a global variable called Entity that holds the Entity class definition (it’s the table that is used as a prototype for creating Entity instances). Since Lua’s global state is inside a table (and that table is called <em>_G</em>), I can access the class by going through that global table and then just calling its constructor with the appropriate parameters passed. And the clevererest part of this is actually the <em>settings</em> table. All entities in Kara derive from an Entity class, which looks like this:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Entity = class(<span class="string">'Entity'</span>)</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entity:init</span><span class="params">(world, x, y, settings)</span></span></div><div class="line">    self.id = getUID()</div><div class="line">    self.dead = <span class="keyword">false</span></div><div class="line">    self.world = world</div><div class="line">    self.x = x</div><div class="line">    self.y = y</div><div class="line">    <span class="keyword">if</span> settings <span class="keyword">then</span></div><div class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(settings) <span class="keyword">do</span> self[k] = v <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>The last few lines being the most important ones, as the attributes of the class are changed according to the settings table. So whenever an object is created you get a choice to add whatever attributes (or even functions) you want to an object, which adds a lot of flexibility, since otherwise you’d have to create many different classes (or add various attributes to the same class) for all different sorts of random properties that can happen in a game.</p>
<h2 id="Readability">Readability</h2>
<p>Reusable code is locked inside mixins and entity specific code is clearly laid out on that entity’s file. This is a huge advantage whenever you’re reading some entity’s code because you never get lost into what is relevant and what isn’t. For example, look at the code for the smoke/dust class:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Dust = class(<span class="string">'Dust'</span>, Entity)</div><div class="line">Dust:include(PhysicsRectangle)</div><div class="line">Dust:include(Timer)</div><div class="line">Dust:include(Fader)</div><div class="line">Dust:include(Visual)</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dust:init</span><span class="params">(world, x, y, settings)</span></span></div><div class="line">    Entity.init(self, world, x, y, settings)</div><div class="line">    self:physicsRectangleInit(self.world.world, x, y, <span class="string">'dynamic'</span>, <span class="number">16</span>, <span class="number">16</span>)</div><div class="line">    self:timerInit()</div><div class="line">    self:faderInit(self.fade_in_time, <span class="number">0</span>, <span class="number">160</span>)</div><div class="line">    self:visualInit(dust, Vector(<span class="number">0</span>, <span class="number">0</span>)) </div><div class="line">  </div><div class="line">    self.scale = <span class="built_in">math</span>.prandom(<span class="number">0.5</span>, <span class="number">1</span>)</div><div class="line">    timer:tween(<span class="number">2</span>, self, {scale = <span class="number">0.25</span>}, <span class="string">'in-out-cubic'</span>)</div><div class="line">    self.body:setGravityScale(<span class="built_in">math</span>.prandom(-<span class="number">0.025</span>, <span class="number">0.025</span>))</div><div class="line">    self.body:setAngularVelocity(<span class="built_in">math</span>.prandom(<span class="built_in">math</span>.pi/<span class="number">8</span>, <span class="built_in">math</span>.pi/<span class="number">2</span>))</div><div class="line">    <span class="keyword">local</span> r = <span class="built_in">math</span>.prandom(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">math</span>.pi)</div><div class="line">    <span class="keyword">local</span> v = <span class="built_in">math</span>.prandom(<span class="number">5</span>, <span class="number">10</span>)</div><div class="line">    self.body:setLinearVelocity(v*<span class="built_in">math</span>.cos(r), v*<span class="built_in">math</span>.sin(r))</div><div class="line">    self:fadeIn(<span class="number">0</span>, self.fade_in_time <span class="keyword">or</span> <span class="number">1</span>, <span class="string">'in-out-cubic'</span>)</div><div class="line">    self:fadeOut(self.fade_in_time <span class="keyword">or</span> <span class="number">1</span>, <span class="number">1</span>, <span class="string">'in-out-cubic'</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dust:update</span><span class="params">(dt)</span></span></div><div class="line">    self.x, self.y = self.body:getPosition()</div><div class="line">    self:timerUpdate(dt)</div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dust:draw</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">if</span> debug_draw <span class="keyword">then</span> self:physicsRectangleDraw() <span class="keyword">end</span></div><div class="line">    self:faderDraw()</div><div class="line">    self:visualDraw()</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>The entity specific code here happens in the constructor after the <em>visualInit</em> call. If I ever look back at this in another month, year or decade I will know that if I want to change the smoke’s behavior I need to change something in that block of entity specific code. If I want to change how to smoke looks I have to change the first parameter in the <em>visualInit</em> call. If I have to change something in how the fading in or out of the effect works, I have to change something in the <em>faderInit</em> call. Everything is very properly divided and hidden and there’s a clear way of knowing where everything is and what everything does.</p>
<img src="http://i.minus.com/iqph8dPtZvk8K.gif" class="center">

<h2 id="ENDING">ENDING</h2>
<p>Hopefully if you could understand any of that you can see why Lua is great and why mixins are the best. There are certainly drawbacks to using this, but <strong>if you’re coding by yourself or with only another programmer</strong> then the rules don’t matter because you can do anything you want. You are a shining star and the world is only waiting for you to shine your bright beautiful light upon it.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This post deals with OOP and Lua]]>
    
    </summary>
    
      <category term="lua" scheme="http://psychoky.me/tags/lua/"/>
    
      <category term="code organization" scheme="http://psychoky.me/tags/code-organization/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Procedural Dungeon Generation #1]]></title>
    <link href="http://psychoky.me/2013/06/30/procedural-dungeon-generation-number-1/"/>
    <id>http://psychoky.me/2013/06/30/procedural-dungeon-generation-number-1/</id>
    <published>2013-07-01T02:43:00.000Z</published>
    <updated>2015-01-09T04:38:27.000Z</updated>
    <content type="html"><![CDATA[<p>This post briefly explains a technique for generating randomized dungeons<a id="more"></a> that is loosely based on the one explained <a href="http://www.youtube.com/watch?v=GcM9Ynfzll0#t=05m20s" target="_blank" rel="external">here</a>.</p>
<h2 id="Grid_Generation">Grid Generation</h2>
<p>Generate a grid:</p>
<img src="/images/grid.png" class="center">

<h2 id="Grid_Difficulty_Coloring">Grid Difficulty Coloring</h2>
<p>Color the grid with x red rooms (hard), y blue rooms (medium) and z green rooms (easy) such that x+y+z = n rooms in the grid (x, y, z can be changed to control difficulty):</p>
<p><strong>1.</strong> First color it with x red rooms such that no red room (or most red rooms) has another same colored neighbor (this can be changed if dungeon difficulty should be higher);<br><strong>2.</strong> Then for each red room color one neighbor blue and one neighbor green;<br><strong>3.</strong> Color the rest of the rooms with the remaining number of rooms for each color.</p>
<img src="/images/color.png" class="center">

<h2 id="Dungeon_Path_Creation">Dungeon Path Creation</h2>
<p>Choose two nodes that are far apart enough and then find a path between them while mostly avoiding red rooms. If you choose a proper x, since red rooms can’t be neighbors to themselves and the pathfinding algorithm doesn’t go for diagonals, it should create a not so direct path from one node to the other.</p>
<img src="/images/path.png" class="center">

<p>For all nodes in the path, add their red[, green, blue] neighbors. This should add the possibility of side paths and overall complexity/difficulty in the dungeon.</p>
<img src="/images/filled-path.png" class="center">

<h2 id="Room_Creation_and_Connection">Room Creation and Connection</h2>
<p>Join smaller grids into bigger ones according to predefined room sizes. Higher chance of smaller width/height and lower chance of bigger width/height.</p>
<img src="/images/join.png" class="center">

<p>Generate all possible connections between rooms.</p>
<img src="/images/connected.png" class="center">

<p>Randomly remove connections until a certain number of connections per room is met. If n = total rooms, then set n*x rooms with &gt;=4 connections, n*y with 3, n*z with 2 and n*w with 1, such that x+y+z+w=1. Controlling x, y, z and w lets you control how mazy the dungeon gets. If z or w are considerably higher than x or y then there won’t be many “hub” rooms that connect different paths, so it’s gonna have lots of different thin paths with dead ends. If x or y are higher then the dungeon will be super connected and therefore easier.</p>
<img src="/images/disconnected.png" class="center">

<p>Reconnect isolated “islands”. Since step 7 is completely random, there’s a big chance that rooms or groups of rooms will become unreachable. </p>
<img src="/images/disconnected-groups.png" class="center">

<p>To fix that:</p>
<p><strong>1.</strong> Flood fill to figure out how many isolated groups exist;<br><strong>2.</strong> Pick a group at random and go through its rooms. For each room check if it neighbors a room belonging to another group, if it does then connect them and end the search;<br><strong>3.</strong> Repeat the previous steps until there’s only one group left (everyone’s connected).</p>
<img src="/images/final.png" class="center">

<h2 id="END">END</h2>
<p>And that’s it, I guess. There’s more stuff like adding special rooms, but that’s specific to each game, so whatever. But basically I have a few parameters I can control when creating a new dungeon: dungeon width/height; percentage of hard, medium and easy rooms; what color neighbors get added to the original path and the percentage of rooms with &gt;=4, 3, 2 or 1 connections. I think that’s enough to have control of how easy/hard the dungeon will be…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This post briefly explains a technique for generating randomized dungeons]]>
    
    </summary>
    
      <category term="procedural" scheme="http://psychoky.me/tags/procedural/"/>
    
  </entry>
  
</feed>
